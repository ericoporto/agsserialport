#ifndef AGS_SERIALPORT_ASH_H
#define AGS_SERIALPORT_ASH_H

const char *agsserialport_ash =
" // new module header  \r\n"
"   \r\n"
" /// Return values.   \r\n"
" enum AGSP_ReturnType   \r\n"
" {  \r\n"
" /// Operation completed successfully.  \r\n"
" eAGSP_OK = 0,  \r\n"
" /// Invalid arguments were passed to the function.   \r\n"
" eAGSP_ERR_ARG = -1,  \r\n"
" /// A system error occurred while executing the operation.   \r\n"
" eAGSP_ERR_FAIL = -2,  \r\n"
" /// A memory allocation failed while executing the operation.  \r\n"
" eAGSP_ERR_MEM = -3,  \r\n"
" /// The requested operation is not supported by this system or device.  \r\n"
" eAGSP_ERR_SUPP = -4  \r\n"
" /// The requested operation was executed in an uninitialized or null object;  \r\n"
" eAGSP_ERR_NULLPTR = -10  \r\n"
" };  \r\n"
"   \r\n"
" /// Port access modes.   \r\n"
" enum AGSP_ModeType   \r\n"
" {  \r\n"
" /// Open port for read access.   \r\n"
" eAGSP_Mode_Read = 1,  \r\n"
" /// Open port for write access.   \r\n"
" eAGSP_Mode_Write = 2,  \r\n"
" /// Open port for read and write access.   \r\n"
" eAGSP_Mode_ReadWrite = 3  \r\n"
" };  \r\n"
"   \r\n"
" /// Buffer selection.  \r\n"
" enum AGSP_BufferType   \r\n"
" {  \r\n"
" /// Input buffer.   \r\n"
" eAGSP_Buf_Input = 1,  \r\n"
" /// Output buffer.  \r\n"
" eAGSP_Buf_Output = 2,  \r\n"
" /// Both buffers.   \r\n"
" eAGSP_Buf_InputOutput = 3  \r\n"
" };  \r\n"
"   \r\n"
" /// Parity settings.   \r\n"
" enum AGSP_ParityType   \r\n"
" {  \r\n"
" /// Special value to indicate setting should be left alone.   \r\n"
" eAGSP_Parity_Invalid = -1,  \r\n"
" /// No parity.   \r\n"
" eAGSP_Parity_None = 0,  \r\n"
" /// Odd parity.   \r\n"
" eAGSP_Parity_Odd = 1,  \r\n"
" /// Even parity.   \r\n"
" eAGSP_Parity_Even = 2,  \r\n"
" /// Mark parity.   \r\n"
" eAGSP_Parity_Mark = 3,  \r\n"
" /// Space parity.   \r\n"
" eAGSP_Parity_Space = 4  \r\n"
" };  \r\n"
"   \r\n"
" /// RTS pin behaviour.   \r\n"
" enum AGSP_RTS_PinType   \r\n"
" {  \r\n"
" /// Special value to indicate setting should be left alone.   \r\n"
" eAGSP_RTS_Invalid = -1,  \r\n"
" /// RTS off.   \r\n"
" eAGSP_RTS_Off = 0,  \r\n"
" /// RTS on.   \r\n"
" eAGSP_RTS_On = 1,  \r\n"
" /// RTS used for flow control.   \r\n"
" eAGSP_RTS_FlowControl = 2  \r\n"
" };  \r\n"
"   \r\n"
" /// CTS pin behaviour.   \r\n"
" enum AGSP_CTS_PinType   \r\n"
" {  \r\n"
" /// Special value to indicate setting should be left alone.   \r\n"
" eAGSP_CTS_Invalid = -1,  \r\n"
" /// CTS ignored.   \r\n"
" eAGSP_CTS_Ignore = 0,  \r\n"
" /// CTS used for flow control.   \r\n"
" eAGSP_CTS_FlowControl = 1  \r\n"
" };  \r\n"
"   \r\n"
" /// DTR pin behaviour.   \r\n"
" enum AGSP_DTR_PinType   \r\n"
" {  \r\n"
" /// Special value to indicate setting should be left alone.   \r\n"
" eAGSP_DTR_Invalid = -1,  \r\n"
" /// DTR off.   \r\n"
" eAGSP_DTR_Off = 0,  \r\n"
" /// DTR on.   \r\n"
" eAGSP_DTR_On = 1,  \r\n"
" /// DTR used for flow control.  \r\n"
" eAGSP_DTR_FlowControl= 2  \r\n"
" };  \r\n"
"   \r\n"
" /// DSR pin behaviour.   \r\n"
" enum AGSP_DSR_PinType   \r\n"
" {  \r\n"
" /// Special value to indicate setting should be left alone.   \r\n"
" eAGSP_DSR_Invalid = -1,  \r\n"
" /// DSR ignored.   \r\n"
" eAGSP_DSR_Ignore = 0,  \r\n"
" /// DSR used for flow control.   \r\n"
" eAGSP_DSR_FlowControl = 1  \r\n"
" };  \r\n"
"   \r\n"
" /// XON/XOFF flow control behaviour.   \r\n"
" enum AGSP_XonXoffType   \r\n"
" {  \r\n"
" /// Special value to indicate setting should be left alone.   \r\n"
" eAGSP_XonXoff_Invalid = -1,  \r\n"
" /// XON/XOFF disabled.   \r\n"
" eAGSP_XonXoff_Disabled = 0,  \r\n"
" /// XON/XOFF enabled for input only.   \r\n"
" eAGSP_XonXoff_In = 1,  \r\n"
" /// XON/XOFF enabled for output only.   \r\n"
" eAGSP_XonXoff_Out = 2,  \r\n"
" /// XON/XOFF enabled for input and output.   \r\n"
" eAGSP_XonXoff_InOut = 3  \r\n"
" };  \r\n"
"   \r\n"
" /// Standard flow control combinations.  \r\n"
" enum AGSP_FlowControlType   \r\n"
" {  \r\n"
" /// No flow control.   \r\n"
" eAGSP_FlowControl_None = 0,  \r\n"
" /// Software flow control using XON/XOFF characters.  \r\n"
" eAGSP_FlowControl_XonXoff = 1,  \r\n"
" /// Hardware flow control using RTS/CTS signals.   \r\n"
" eAGSP_FlowControl_RTSCTS = 2,  \r\n"
" /// Hardware flow control using DTR/DSR signals.   \r\n"
" eAGSP_FlowControl_DTRDSR = 3  \r\n"
" };  \r\n"
"   \r\n"
" /// Input signals.   \r\n"
" enum AGSP_SignalType   \r\n"
" {  \r\n"
" /// Clear to send.   \r\n"
" eAGSP_Signal_CTS = 1,  \r\n"
" /// Data set ready.   \r\n"
" eAGSP_Signal_DSR = 2,  \r\n"
" /// Data carrier detect.   \r\n"
" eAGSP_Signal_DCD = 4,  \r\n"
" /// Ring indicator.   \r\n"
" eAGSP_Signal_RI = 8  \r\n"
" };  \r\n"
"   \r\n"
" /// Transport types.  \r\n"
" enum AGSP_TransportType   \r\n"
" {  \r\n"
" /// Native platform serial port.   \r\n"
" eAGSP_Transport_Native,  \r\n"
" /// USB serial port adapter.   \r\n"
" eAGSP_Transport_USB,  \r\n"
" /// Bluetooth serial port adapter.   \r\n"
" eAGSP_TransportT_Bluetooth  \r\n"
" };  \r\n"
"   \r\n"
" /// structure representing the configuration for a serial port.  \r\n"
" builtin managed struct SP_PortConfig  \r\n"
" {  \r\n"
" /// Create a port configuration structure.  \r\n"
" import static SP_PortConfig* Create(); // $AUTOCOMPLETESTATICONLY$   \r\n"
" /// The baud rate from a port configuration.  \r\n"
" import attribute int Baudrate;  \r\n"
" import int get_Baudrate(); // $AUTOCOMPLETEIGNORE$  \r\n"
" import void set_Baudrate(int baudrate); // $AUTOCOMPLETEIGNORE$  \r\n"
" /// The data bits in a port configuration.  \r\n"
" import attribute int Bits;  \r\n"
" import int get_Bits(); // $AUTOCOMPLETEIGNORE$  \r\n"
" import void set_Bits(int bits); // $AUTOCOMPLETEIGNORE$  \r\n"
" /// The parity setting in a port configuration.  \r\n"
" import attribute AGSP_ParityType Parity;  \r\n"
" import AGSP_ParityType get_Parity(); // $AUTOCOMPLETEIGNORE$  \r\n"
" import void set_Parity(AGSP_ParityType parity); // $AUTOCOMPLETEIGNORE$  \r\n"
" /// The stop bits in a port configuration.  \r\n"
" import attribute int StopBits;  \r\n"
" import int get_StopBits(); // $AUTOCOMPLETEIGNORE$  \r\n"
" import void set_StopBits(int stopbits); // $AUTOCOMPLETEIGNORE$  \r\n"
" /// The RTS pin behaviour from a port configuration  \r\n"
" import attribute AGSP_RTS_PinType RTS;  \r\n"
" import AGSP_RTS_PinType get_RTS(); // $AUTOCOMPLETEIGNORE$  \r\n"
" import void set_RTS(AGSP_RTS_PinType rts); // $AUTOCOMPLETEIGNORE$  \r\n"
" /// The CTS pin behaviour in a port configuration.  \r\n"
" import attribute AGSP_CTS_PinType CTS;  \r\n"
" import AGSP_CTS_PinType get_CTS(); // $AUTOCOMPLETEIGNORE$  \r\n"
" import void set_CTS(AGSP_CTS_PinType cts); // $AUTOCOMPLETEIGNORE$  \r\n"
" /// The DTR pin behaviour in a port configuration  \r\n"
" import attribute AGSP_DTR_PinType DTR;  \r\n"
" import AGSP_DTR_PinType get_DTR(); // $AUTOCOMPLETEIGNORE$  \r\n"
" import void set_DTR(AGSP_DTR_PinType dtr); // $AUTOCOMPLETEIGNORE$  \r\n"
" /// The DSR pin behaviour in a port configuration.  \r\n"
" import attribute AGSP_DSR_PinType DSR;  \r\n"
" import AGSP_DSR_PinType get_DSR(); // $AUTOCOMPLETEIGNORE$  \r\n"
" import void set_DSR(AGSP_DSR_PinType dsr); // $AUTOCOMPLETEIGNORE$  \r\n"
" /// The XON/XOFF configuration in a port configuration.  \r\n"
" import attribute AGSP_XonXoffType XonXoff;  \r\n"
" import AGSP_XonXoffType get_XonXoff(); // $AUTOCOMPLETEIGNORE$  \r\n"
" import void set_XonXoff(AGSP_XonXoffType xonxoff); // $AUTOCOMPLETEIGNORE$  \r\n"
"   \r\n"
" /// Sets the RTS, CTS, DTR, DSR and XON/XOFF as necessary for the specified flow control type.  \r\n"
" import void SetFlowControl(AGSP_FlowControlType flowcontrol);   \r\n"
" };  \r\n"
"   \r\n"
" /// structure representing a serial port.  \r\n"
" builtin managed struct SP_Port  \r\n"
" {  \r\n"
" /// Creates a port from the OS-specific name of a serial port.  \r\n"
" import static SP_Port* Create(String portname); // $AUTOCOMPLETESTATICONLY$   \r\n"
" /// Open the specified serial port.  \r\n"
" import AGSP_ReturnType Open(AGSP_ModeType mode);  \r\n"
" /// Close the specified serial port. Port must be open.  \r\n"
" import AGSP_ReturnType Close();  \r\n"
" /// Get the name of a port. The name returned is whatever is normally used to refer to a port on the current operating system.  \r\n"
" import readonly attribute String Name;  \r\n"
" import String get_Name(); // $AUTOCOMPLETEIGNORE$  \r\n"
" /// Get a description for a port, to present to end user.  \r\n"
" import readonly attribute String Description;  \r\n"
" import String get_Description(); // $AUTOCOMPLETEIGNORE$  \r\n"
" /// Get the transport type used by a port. Port must be open.  \r\n"
" import readonly attribute AGSP_TransportType Transport;  \r\n"
" import AGSP_TransportType get_Transport(); // $AUTOCOMPLETEIGNORE$  \r\n"
" /// Get Port configuration. Port must be open.  \r\n"
" import SP_PortConfig* GetConfig();  \r\n"
" /// Set Port configuration. Port must be open.  \r\n"
" import AGSP_ReturnType SetConfig(SP_PortConfig* config);  \r\n"
" /// Read bytes from the specified serial port, without blocking. Port must be open.  \r\n"
" import String Read(int count);  \r\n"
" /// Write bytes to the specified serial port, without blocking. Port must be open.  \r\n"
" import AGSP_ReturnType Write(String buffer);  \r\n"
" /// Gets the number of bytes waiting in the input buffer. Port must be open.  \r\n"
" import readonly attribute AGSP_ReturnType WaitingBytesRead;  \r\n"
" import AGSP_ReturnType get_WaitingBytesRead(); // $AUTOCOMPLETEIGNORE$  \r\n"
" /// Gets the number of bytes waiting in the output buffer. Port must be open.  \r\n"
" import readonly attribute AGSP_ReturnType WaitingBytesWrite;  \r\n"
" import AGSP_ReturnType get_WaitingBytesWrite(); // $AUTOCOMPLETEIGNORE$  \r\n"
" /// Flush serial port buffers. Data in the selected buffer(s) is discarded. Port must be open.  \r\n"
" import AGSP_ReturnType Flush(AGSP_BufferType buffers);  \r\n"
"   \r\n"
" /// Set port Baudrate. Port must be open.  \r\n"
" import AGSP_ReturnType SetBaudrate(int baudrate);  \r\n"
" /// Set port Bits. Port must be open.  \r\n"
" import AGSP_ReturnType SetBits(int bits);  \r\n"
" /// Set port Parity. Port must be open.  \r\n"
" import AGSP_ReturnType SetParity(AGSP_ParityType parity);  \r\n"
" /// Set port Stop Bits. Port must be open.  \r\n"
" import AGSP_ReturnType SetStopBits(int StopBits);  \r\n"
" /// Sets the RTS, CTS, DTR, DSR and XON/XOFF as necessary for the specified port flow control type. Port must be open.  \r\n"
" import AGSP_ReturnType SetFlowControl(AGSP_FlowControlType flowcontrol);  \r\n"
" };  \r\n"
"   \r\n"
" builtin managed struct AGSP  \r\n"
" {  \r\n"
" /// Refreshes Port Names list  \r\n"
" import static void UpdatePortNames();  \r\n"
" /// Get the number of serial ports.  \r\n"
" import static attribute int PortNamesCount; // $AUTOCOMPLETESTATICONLY$   \r\n"
" import static int get_PortNamesCount(); // $AUTOCOMPLETEIGNORE$  \r\n"
" /// Get the OS-specific name of a serial port by index.  \r\n"
" import static readonly attribute String PortNames[]; // $AUTOCOMPLETESTATICONLY$   \r\n"
" import static String get_PortNames(int i); // $AUTOCOMPLETEIGNORE$  \r\n"
" };  \r\n"
;

#endif // AGS_SERIALPORT_ASH_H
